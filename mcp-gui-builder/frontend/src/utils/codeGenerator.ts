import type { ServerConfig, Tool, Resource, GeneratedCode } from '../types';
import { ToolType } from '../types';

export const generateCode = (
  serverConfig: ServerConfig,
  tools: Tool[],
  resources: Resource[]
): GeneratedCode => {
  const validTools = tools.filter(tool => tool.isValid);

  return {
    mainPy: generateMainPy(serverConfig, validTools, resources),
    requirements: generateRequirements(serverConfig, validTools),
    dockerfile: generateDockerfile(serverConfig),
    dockerCompose: generateDockerCompose(serverConfig),
    readme: generateReadme(serverConfig, validTools, resources),
    envExample: generateEnvExample(serverConfig),
    tests: generateTests(serverConfig, validTools, resources)
  };
};

const generateMainPy = (serverConfig: ServerConfig, tools: Tool[], resources: Resource[]): string => {
  const imports = new Set([
    'import asyncio',
    'import logging',
    'from typing import Any, Dict, List, Optional',
    'from fastmcp import FastMCP, Context'
  ]);

  // Add tool-specific imports
  tools.forEach(tool => {
    switch (tool.type) {
      case ToolType.FILE_READER:
        imports.add('import os');
        imports.add('import pandas as pd');
        imports.add('from pathlib import Path');
        break;
      case ToolType.API_CALLER:
        imports.add('import httpx');
        imports.add('import aiohttp');
        break;
      case ToolType.DATABASE:
        imports.add('import sqlalchemy');
        imports.add('from sqlalchemy import create_engine');
        break;
      case ToolType.WEB_SCRAPER:
        imports.add('import requests');
        imports.add('from bs4 import BeautifulSoup');
        break;
      case ToolType.EMAIL_SENDER:
        imports.add('import smtplib');
        imports.add('from email.mime.text import MIMEText');
        imports.add('from email.mime.multipart import MIMEMultipart');
        break;
      case ToolType.IMAGE_PROCESSOR:
        imports.add('from PIL import Image');
        imports.add('import cv2');
        break;
      case ToolType.TEXT_ANALYZER:
        imports.add('import spacy');
        imports.add('from textblob import TextBlob');
        break;
      case ToolType.CALCULATOR:
        imports.add('import math');
        imports.add('import numpy as np');
        break;
    }
  });

  const toolFunctions = tools.map(generateToolFunction).join('\n\n');
  const resourceFunctions = generateResourceFunctions(resources);
  const toolRegistrations = tools.map(tool => `mcp.add_tool("${tool.name}", ${tool.name})`).join('\n    ');
  const resourceRegistrations = resources.map(resource => `mcp.add_resource("${resource.uri}", get_${sanitizeIdentifier(resource.name)})`).join('\n    ');

  return `#!/usr/bin/env python3
"""
${serverConfig.name} - ${serverConfig.description}

Generated by MCP GUI Builder
Author: ${serverConfig.author}
Version: ${serverConfig.version}
"""

${Array.from(imports).join('\n')}

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("${serverConfig.name}")

# Initialize FastMCP
mcp = FastMCP("${serverConfig.name}")

${toolFunctions}

${resourceFunctions}

def setup_server():
    """Setup and configure the MCP server."""
    logger.info("Setting up ${serverConfig.name}...")

    # Register tools
    ${toolRegistrations}

    # Register resources
    ${resourceRegistrations}

    logger.info("Server setup complete!")

async def main():
    """Main server entry point."""
    setup_server()

    # Start the server
    logger.info("Starting ${serverConfig.name}...")
    await mcp.run()

if __name__ == "__main__":
    asyncio.run(main())
`;
};

const generateToolFunction = (tool: Tool): string => {
  const params = tool.parameters.map(param => {
    const typeHint = getTypeHint(param.type);
    const defaultValue = param.default ? ` = ${JSON.stringify(param.default)}` : '';
    const optional = !param.required ? 'Optional[' + typeHint + ']' : typeHint;
    return `${param.name}: ${optional}${defaultValue}`;
  }).join(', ');

  const docstring = `    """${tool.description}

    Args:
${tool.parameters.map(param => `        ${param.name}: ${param.description}`).join('\n')}

    Returns:
        ${getTypeHint(tool.returnType.type)}: ${tool.description}
    """`;

  const functionDef = tool.isAsync ? 'async def' : 'def';
  const returnType = getTypeHint(tool.returnType.type);

  let functionBody = generateToolBody(tool);

  return `${functionDef} ${tool.name}(ctx: Context${params ? ', ' + params : ''}) -> ${returnType}:
${docstring}
    logger.info(f"Executing tool: ${tool.name}")

    try:
${functionBody.split('\n').map(line => '        ' + line).join('\n')}
    except Exception as e:
        logger.error(f"Error in ${tool.name}: {str(e)}")
        raise`;
};

const generateToolBody = (tool: Tool): string => {
  switch (tool.type) {
    case ToolType.FILE_READER:
      return `# File reading logic
file_path = Path(file_path)
if not file_path.exists():
    raise FileNotFoundError(f"File not found: {file_path}")

if file_path.suffix == '.csv':
    df = pd.read_csv(file_path)
    return df.to_dict('records')
elif file_path.suffix == '.json':
    with open(file_path, 'r') as f:
        return json.load(f)
else:
    with open(file_path, 'r') as f:
        return f.read()`;

    case ToolType.API_CALLER:
      return `# API call logic
async with httpx.AsyncClient() as client:
    response = await client.get(url)
    response.raise_for_status()
    return response.json()`;

    case ToolType.CALCULATOR:
      return `# Mathematical calculation
result = eval(expression)  # Note: In production, use a safe evaluator
return result`;

    case ToolType.DATABASE:
      return `# Database query logic
engine = create_engine(connection_string)
with engine.connect() as conn:
    result = conn.execute(query)
    return [dict(row) for row in result]`;

    case ToolType.WEB_SCRAPER:
      return `# Web scraping logic
response = requests.get(url)
response.raise_for_status()
soup = BeautifulSoup(response.content, 'html.parser')
return str(soup)`;

    case ToolType.EMAIL_SENDER:
      return `# Email sending logic
msg = MIMEText(body)
msg['Subject'] = subject
msg['From'] = from_address
msg['To'] = to_address

with smtplib.SMTP(smtp_host, smtp_port) as server:
    server.starttls()
    server.login(username, password)
    server.send_message(msg)

return "Email sent successfully"`;

    case ToolType.IMAGE_PROCESSOR:
      return `# Image processing logic
img = Image.open(image_path)
processed_img = img.resize((width, height))
processed_img.save(output_path)
return f"Image processed and saved to {output_path}"`;

    case ToolType.TEXT_ANALYZER:
      return `# Text analysis logic
blob = TextBlob(text)
sentiment = blob.sentiment
return {
    'polarity': sentiment.polarity,
    'subjectivity': sentiment.subjectivity,
    'text': text
}`;

    default:
      return `# Custom tool implementation
# TODO: Implement your custom logic here
return "Tool executed successfully"`;
  }
};

const generateResourceFunctions = (resources: Resource[]): string => {
  return resources.map(resource => {
    const functionName = `get_${sanitizeIdentifier(resource.name)}`;

    return `async def ${functionName}(uri: str) -> str:
    """Get resource: ${resource.name}"""
    logger.info(f"Accessing resource: ${resource.uri}")

    ${resource.type === 'static'
      ? `# Static resource
    return """${resource.content || ''}"""`
      : `# Dynamic resource
    # TODO: Implement resource fetching logic
    return "Resource content"`
    }`;
  }).join('\n\n');
};

const generateRequirements = (serverConfig: ServerConfig, tools: Tool[]): string => {
  const dependencies = new Set([
    'fastmcp>=0.1.0',
    'asyncio-compat>=0.1.0'
  ]);

  // Add tool-specific dependencies
  tools.forEach(tool => {
    switch (tool.type) {
      case ToolType.FILE_READER:
        dependencies.add('pandas>=2.0.0');
        dependencies.add('PyPDF2>=3.0.0');
        dependencies.add('python-docx>=0.8.11');
        dependencies.add('openpyxl>=3.1.0');
        break;
      case ToolType.API_CALLER:
        dependencies.add('httpx>=0.25.0');
        dependencies.add('aiohttp>=3.9.0');
        break;
      case ToolType.DATABASE:
        dependencies.add('sqlalchemy>=2.0.0');
        dependencies.add('asyncpg>=0.29.0');
        break;
      case ToolType.WEB_SCRAPER:
        dependencies.add('requests>=2.31.0');
        dependencies.add('beautifulsoup4>=4.12.0');
        dependencies.add('lxml>=4.9.0');
        dependencies.add('selenium>=4.15.0');
        break;
      case ToolType.IMAGE_PROCESSOR:
        dependencies.add('Pillow>=10.0.0');
        dependencies.add('opencv-python>=4.8.0');
        break;
      case ToolType.TEXT_ANALYZER:
        dependencies.add('spacy>=3.7.0');
        dependencies.add('textblob>=0.17.1');
        dependencies.add('nltk>=3.8.0');
        break;
      case ToolType.CALCULATOR:
        dependencies.add('numpy>=1.24.0');
        dependencies.add('scipy>=1.11.0');
        dependencies.add('sympy>=1.12.0');
        break;
    }
  });

  // Add user-specified dependencies
  serverConfig.dependencies.forEach(dep => dependencies.add(dep));

  return Array.from(dependencies).sort().join('\n');
};

const generateDockerfile = (serverConfig: ServerConfig): string => {
  return `FROM python:${serverConfig.pythonVersion}-slim

# Set working directory
WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \\
    gcc \\
    && rm -rf /var/lib/apt/lists/*

# Copy requirements first for better caching
COPY requirements.txt .

# Install Python dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Create non-root user
RUN useradd --create-home --shell /bin/bash mcpuser && \\
    chown -R mcpuser:mcpuser /app

USER mcpuser

# Health check
HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \\
    CMD python -c "import requests; requests.get('http://localhost:8000/health')" || exit 1

# Expose port
EXPOSE 8000

# Run the application
CMD ["python", "main.py"]
`;
};

const generateDockerCompose = (serverConfig: ServerConfig): string => {
  const envVarsList = Object.keys(serverConfig.environment).length > 0
    ? Object.keys(serverConfig.environment).map(key => `      - ${key}=\${${key}}`).join('\n')
    : '      # No environment variables configured';

  return `version: '3.8'

services:
  ${serverConfig.name}:
    build: .
    ports:
      - "8000:8000"
    environment:
${envVarsList}
    volumes:
      - ./data:/app/data
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "python", "-c", "import requests; requests.get('http://localhost:8000/health')"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # Uncomment if you need a database
  # postgres:
  #   image: postgres:15
  #   environment:
  #     POSTGRES_DB: ${serverConfig.name}
  #     POSTGRES_USER: \${DB_USER:-mcpuser}
  #     POSTGRES_PASSWORD: \${DB_PASSWORD}
  #   ports:
  #     - "5432:5432"
  #   volumes:
  #     - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
`;
};

const generateReadme = (serverConfig: ServerConfig, tools: Tool[], resources: Resource[]): string => {
  const toolsList = tools.map(tool => `- **${tool.name}**: ${tool.description}`).join('\n');
  const resourcesList = resources.map(resource => `- **${resource.name}** (\`${resource.uri}\`): ${resource.description}`).join('\n');
  const envVarsList = Object.entries(serverConfig.environment).map(
    ([key, envVar]) => `- \`${key}\`: ${envVar.description}${envVar.required ? ' (required)' : ''}`
  ).join('\n');

  return `# ${serverConfig.name}

${serverConfig.description}

**Author**: ${serverConfig.author}
**Version**: ${serverConfig.version}
**Python**: ${serverConfig.pythonVersion}+

*Generated with [MCP GUI Builder](https://github.com/anthropics/mcp-gui-builder)*

## Features

### Tools
${toolsList || 'No tools configured'}

### Resources
${resourcesList || 'No resources configured'}

## Installation

### Local Development

1. Clone or download this repository
2. Install dependencies:
   \`\`\`bash
   pip install -r requirements.txt
   \`\`\`
3. Set up environment variables (see [Environment Variables](#environment-variables))
4. Run the server:
   \`\`\`bash
   python main.py
   \`\`\`

### Docker

1. Build the image:
   \`\`\`bash
   docker build -t ${serverConfig.name} .
   \`\`\`
2. Run the container:
   \`\`\`bash
   docker run -p 8000:8000 ${serverConfig.name}
   \`\`\`

### Docker Compose

1. Set up environment variables in \`.env\` file
2. Start the services:
   \`\`\`bash
   docker-compose up -d
   \`\`\`

## Environment Variables

${envVarsList || 'No environment variables required'}

Copy \`.env.example\` to \`.env\` and fill in your values.

## Usage

Once the server is running, you can use it with Claude Desktop or any MCP-compatible client:

\`\`\`json
{
  "servers": {
    "${serverConfig.name}": {
      "command": "python",
      "args": ["/path/to/${serverConfig.name}/main.py"],
      "env": {
${Object.keys(serverConfig.environment).map(key => `        "${key}": "your_value_here"`).join(',\n')}
      }
    }
  }
}
\`\`\`

## Development

### Running Tests

\`\`\`bash
python -m pytest test_server.py -v
\`\`\`

### Adding New Tools

1. Edit \`main.py\`
2. Add your tool function following the existing pattern
3. Register it with \`mcp.add_tool()\`
4. Update requirements.txt if needed

### Debugging

Enable debug logging by setting the log level:

\`\`\`python
logging.basicConfig(level=logging.DEBUG)
\`\`\`

## License

This project was generated using MCP GUI Builder. Customize as needed for your use case.

## Support

For issues with the generated code, please check:

1. [MCP Documentation](https://modelcontextprotocol.io/)
2. [FastMCP Documentation](https://github.com/jlowin/fastmcp)
3. [MCP GUI Builder Issues](https://github.com/anthropics/mcp-gui-builder/issues)
`;
};

const generateEnvExample = (serverConfig: ServerConfig): string => {
  const envVars = Object.entries(serverConfig.environment).map(([key, envVar]) => {
    const comment = envVar.description ? `# ${envVar.description}` : '';
    const required = envVar.required ? ' (required)' : '';
    const secret = envVar.secret ? ' (secret)' : '';
    const value = envVar.secret ? '' : (envVar.value || '');

    return `${comment}${required}${secret}\n${key}=${value}`;
  }).join('\n\n');

  return `# Environment variables for ${serverConfig.name}
# Copy this file to .env and fill in your values

${envVars || '# No environment variables configured'}

# Optional: Set log level
# LOG_LEVEL=INFO

# Optional: Set server host and port
# HOST=0.0.0.0
# PORT=8000
`;
};

const generateTests = (serverConfig: ServerConfig, tools: Tool[], resources: Resource[]): string => {
  const testFunctions = tools.map(tool => {
    const testParams = tool.parameters.map(param => {
      const value = getTestValue(param.type);
      return `${param.name}=${JSON.stringify(value)}`;
    }).join(', ');

    return `    async def test_${tool.name}(self):
        """Test ${tool.name} tool."""
        result = await ${tool.name}(self.ctx${testParams ? ', ' + testParams : ''})
        self.assertIsNotNone(result)
        # Add specific assertions based on expected output`;
  }).join('\n\n');

  return `#!/usr/bin/env python3
"""
Test suite for ${serverConfig.name}

Run with: python -m pytest test_server.py -v
"""

import unittest
import asyncio
from unittest.mock import Mock, patch
from fastmcp import Context

# Import your server functions
from main import *


class TestMCPServer(unittest.IsolatedAsyncioTestCase):
    """Test cases for MCP server tools and resources."""

    def setUp(self):
        """Set up test fixtures."""
        self.ctx = Mock(spec=Context)

    async def test_server_setup(self):
        """Test server setup and configuration."""
        # Test that setup_server runs without errors
        setup_server()
        self.assertTrue(True)  # If we get here, setup succeeded

${testFunctions}

    async def test_all_tools_registered(self):
        """Test that all tools are properly registered."""
        expected_tools = [${tools.map(tool => `"${tool.name}"`).join(', ')}]
        # Add assertions to check tool registration

    async def test_all_resources_available(self):
        """Test that all resources are accessible."""
        expected_resources = [${resources.map(resource => `"${resource.uri}"`).join(', ')}]
        # Add assertions to check resource availability


class TestToolValidation(unittest.TestCase):
    """Test tool parameter validation."""

    def test_parameter_types(self):
        """Test that parameters accept correct types."""
        # Add parameter validation tests
        pass

    def test_required_parameters(self):
        """Test that required parameters are enforced."""
        # Add required parameter tests
        pass


class TestErrorHandling(unittest.IsolatedAsyncioTestCase):
    """Test error handling and edge cases."""

    async def test_invalid_inputs(self):
        """Test handling of invalid inputs."""
        # Add error handling tests
        pass

    async def test_network_failures(self):
        """Test handling of network failures for API tools."""
        # Add network failure tests
        pass


if __name__ == '__main__':
    unittest.main()
`;
};

// Helper functions
const getTypeHint = (type: string): string => {
  switch (type) {
    case 'string': return 'str';
    case 'number': return 'float';
    case 'boolean': return 'bool';
    case 'object': return 'Dict[str, Any]';
    case 'array': return 'List[Any]';
    case 'void': return 'None';
    default: return 'Any';
  }
};

const getTestValue = (type: string): any => {
  switch (type) {
    case 'string': return 'test_string';
    case 'number': return 123;
    case 'boolean': return true;
    case 'object': return { test: 'value' };
    case 'array': return ['test', 'array'];
    default: return 'test_value';
  }
};

const sanitizeIdentifier = (name: string): string => {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9]/g, '_')
    .replace(/^[0-9]/, '_')
    .replace(/_+/g, '_')
    .replace(/^_|_$/g, '');
};